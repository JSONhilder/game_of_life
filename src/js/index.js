const _ggg = [
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0       
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0       
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0       
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
    0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 1, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
    0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 1, 0
  ],
  [
    0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 1, 0, 1, 1, 0,
    0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
  ]
]

const _toad = [
  [0,0,0,0,0,0],
  [0,0,0,0,0,0],
  [0,0,1,1,1,0],
  [0,1,1,1,0,0],
  [0,0,0,0,0,0],
  [0,0,0,0,0,0]
]

function dead_state(_width, _height)
{
    let board = [];

    for (let row = 0; row < _height; row++) {
        
        let generated_row = [];

        for (let column = 0; column < _width; column++) {
            generated_row.push(0);
        };
       
        board.push(generated_row);
    };

    return board;
};

function random_state(_width, _height) 
{

    let state = dead_state(_width, _height);

    for (let row = 0; row < _height; row++) {
        //For each row
        for (let column = 0; column < _width; column++) {
            // For each column in current row
            let rng = Math.random() * Math.floor(1);

            if (rng > 0.45) state[row][column] = 1
            else state[row][column] = 0

        };
    };

    return state;
}

function render(board) {
    // print starting line
    //console.log("-".repeat(board[0].length * 2 + 1));

    for (let row = 0; row < board.length; row++) {
        let format_row = [];
        
        for (let column = 0; column < board[row].length; column++) {

            let cur_num = board[row][column]
            
            if (cur_num === 1) format_row.push("\u25A0")
            else format_row.push(' ');
        
        };
        console.log(format_row.join(" "));
    };

    // print finishing line
    //console.log("-".repeat(board[0].length * 2 + 1));
};

function cell_check(co_ords, state) {
    /**
     * Check each value of state 
     * check up then up + right then up + left
     * check down then down + right then down + left
     * check left then right
     * 
     * if the check == 1 add to neighbor_count else do not.
     * 
     * if neighbor_count <= 1 make new state value 0
     * if neighbor_count >= 2 or <= 3 make new state value 1
     * if neighbor_count >3 make new state value 0
     * if neighbor_count == 3 then if current value 0 make new state 1
     * 
    */

    let neighbor_count = 0;

    const x = co_ords[0];
    const x_start = x - 1;

    const y = co_ords[1];
    const y_start = y - 1;

    for (let row = x_start; row <= x_start + 2; row++) {
        // check for corners
        if (row < 0 || row >= state.length) continue;

        for (let col = y_start; col <= y_start + 2; col++) {
            // check for edges
            if (col < 0 || col >= state[0].length) continue;
            // dont check current cell
            if (row === x && col === y) continue;

            if (state[row][col] === 1) neighbor_count += 1;
           
        };

    };

    // If current position is alive
    if (state[x][y] === 1) {
        if (neighbor_count <= 1) {
            return 0;
        }
        else if (neighbor_count <= 3) {
            return 1;
        }
        else return 0;

    } else {
        if (neighbor_count === 3) {
            return 1;
        }
        else return 0;
    }
};

function next_board_state(init_state) 
{
    let new_state = dead_state(init_state[0].length, init_state.length);

    // loop over intial state rows
    for (let row = 0; row < init_state.length; row++) {
        // loop over current row's columns
        for (let col = 0; col < init_state[0].length; col++) {
            new_state[row][col] = cell_check([row, col], init_state);
        };
    };

    return new_state;
};

function sleep(milliseconds) 
{
    var start = new Date().getTime();
    for (var i = 0; i < 1e7; i++) {
        if ((new Date().getTime() - start) > milliseconds) {
            break;
        }
    }
};

function eternal_life(init_state) 
{
    
    let next_state = init_state;
    while (true) {
        render(next_state);
        next_state = next_board_state(next_state);
        
        sleep(175);
    }
    
};

// Stop/Start Button
function checkLoop() {
  var _value = document.getElementById("loop-button").value;

  if (_value === "no-loop") {
    document.getElementById("loop-button").value = "looping";
    document.getElementById("loop-button").innerText = "stop"
    loop();

  } else {
    document.getElementById("loop-button").value = "no-loop";
    document.getElementById("loop-button").innerText = "start"
    noLoop();
    
  }
};

function loadGosper() {
  arr = _ggg;
  document.getElementById("board-title").innerText = "Gosper Glider Gun"
  setup((arr[0].length * scale), (arr.length * scale-60));
  draw();
};

function loadToad() {
  arr = _toad;
  document.getElementById("board-title").innerText = "Toad"
  setup();
  draw();
};

function genRandomBoard() {
  arr = random_state(40, 30);
  document.getElementById("board-title").innerText = "Random Board"
  setup();
  draw();
};

function createYourOwn() {

};

// random board to start with
let arr = random_state(40, 30);

let scale = 20;

function setup(_w=(arr[0].length * scale), _y=(arr.length * scale)) {
  // width then height
  createCanvas(_w, _y);
  noLoop();
  frameRate(8);
};

function draw() {
background(51);

arr = next_board_state(arr);

//Get the length of columns 'x axis' -- cell
for(var i = 0; i < arr[0].length; i ++) {
    //Get the length of rows 'y axis' -- row
    for(var j = 0; j < arr.length; j++) {
        
        // create current location in x-y co-ords to place the grids
        var x = i * scale;
        var y = j * scale;

        if(arr[j][i] === 1) {
            fill(0);
            stroke(0);
            // create a shape at x and y and then fill (scale number) on the y(up) and (scale number) on the x (right)
            rect(x, y, scale, scale)
        } else {
            fill(255);
            stroke(0);
            rect(x, y, scale, scale)
        }
    }
  }
};

